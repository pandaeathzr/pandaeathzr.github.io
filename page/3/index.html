<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>熊猫吃展瑞</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="熊猫吃展瑞">
<meta property="og:url" content="https://pandaeathzr.github.io/page/3/index.html">
<meta property="og:site_name" content="熊猫吃展瑞">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="熊猫吃展瑞">
  
    <link rel="alternate" href="/atom.xml" title="熊猫吃展瑞" type="application/atom+xml">
  
  
    <link rel="icon" href="/fancybox/panda.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" integrity="sha384-XdYbMnZ/QjLh6iI4ogqCTaIjrFk87ip+ekIjefZch0Y+PvJ8CDYtEs1ipDmPorQ+" crossorigin="anonymous">

  <link rel="stylesheet" href="/css/styles.css">
  

</head>

<body>
  <nav class="navbar navbar-inverse">
  <div class="container">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#main-menu-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="main-menu-navbar">
      <ul class="nav navbar-nav">
        
          <li><a class=""
                 href="/index.html">Home</a></li>
        
          <li><a class=""
                 href="/archives/">Archives</a></li>
        
      </ul>

      <!--
      <ul class="nav navbar-nav navbar-right">
        
          <li><a href="/atom.xml" title="RSS Feed"><i class="fa fa-rss"></i></a></li>
        
      </ul>
      -->
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

  <div class="container">
    <div class="blog-header">
  <h1 class="blog-title">熊猫吃展瑞</h1>
  
    <p class="lead blog-description">愿你是所期待的样子</p>
  
</div>

    <div class="row">
        <div class="col-sm-8 blog-main">
          
  
    <article id="post-用户数据报和IP分片" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/用户数据报和IP分片/">用户数据报协议和IP分片</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/13/用户数据报和IP分片/" class="article-date"><time datetime="2018-04-13T12:46:25.000Z" itemprop="datePublished">2018-04-13</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>UDP是一种保留消息边界的简单的面向数据报的传输层协议。它仅提供差错检测。只是检测，而不是纠正，它只是把应用程序传给IP层的数据发送出去，但是并不会保证数据能够完好无损的到达目的地。</p>
<p>下图是UDP数据报的封装。</p>
<p><img src="https://i.imgur.com/jjSjtna.jpg" alt=""></p>
<hr>
<h2 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h2><p>端口号就如同邮箱一样，用来辨别发送和接受进程。端口号长16比特。</p>
<p>UDP头部如图所示：</p>
<p><img src="https://i.imgur.com/y5t8QUT.jpg" alt=""></p>
<ul>
<li>源端口号（可选），如果发送方并不要求回复，则置0</li>
<li>目的端口号，帮助分离IP层进入的数据</li>
<li>长度，UDP数据报的长度（包过头部和数据）</li>
<li>校验和</li>
</ul>
<p>IP层根据协议头部可以将IP数据报分离到特定的传输协议。正因为如此，不同传输协议是独立的，即可以使用相同的端口号而不会引起冲突。</p>
<p><strong>校验和字段是端到端的，是对包含了IP头部中的源和目的IP地址字段的UDP伪头部计算得到的</strong>，伪头部的目的是用于校验和的计算，他不会被发送出去。</p>
<p>UDP伪头部和头部的格式如图：</p>
<p><img src="https://i.imgur.com/IVtmWq9.jpg" alt=""></p>
<p>伪头部包含了IP头部的源和目的地址，以及协议或下一个头部字段。<strong>目的是让UDP层验证数据是不是到达真正的目的地</strong>，由于有了这样的结构，当该数据报经过一个NAT时候，不仅仅IP层头部的校验和要被修改，并且UDP伪头部的校验和也要被修改。</p>
<hr>
<h3 id="UDP-Lite"><a href="#UDP-Lite" class="headerlink" title="UDP-Lite"></a>UDP-Lite</h3><p>背景：有些应用程序可以容忍在发送和接收的数据里引入的比的差错。</p>
<p>为了避免建议连接的开销，或者为了使用广播或组播地址，这类程序会选择使用UDP。而UDP-Lit提供了<strong>部分校验和</strong>来解决这个问题。</p>
<p>其头部如下表示：</p>
<p><img src="https://i.imgur.com/ZuxP9x8.jpg" alt=""></p>
<p>校验和覆盖范围字段表示被校验和覆盖的字节数。<strong>值为0表示整个数据包都被覆盖</strong>。由于整个头部总是要被覆盖的，所以值位1~7是无效的！</p>
<hr>
<h2 id="IP分片"><a href="#IP分片" class="headerlink" title="IP分片"></a>IP分片</h2><p>为了保持IP数据报抽象与链路层细节的一致和分离，IP引入了分片和重组。</p>
<ul>
<li>IPv4的分片可以在发送主机和端到端路径上的路由器进行</li>
<li>IPv6只允许源主机进行分片</li>
</ul>
<p>重组只能发生在IP数据报到达最终目的地的时候。原因很显然，不同分片可能会经过不同的路径到达目的地，在路径上的路由器只能看到分片的一个子集，显然无法重组。</p>
<hr>
<p>分片由IPV4头部中的标识，分片偏移，和更多分片字段控制。</p>
<ul>
<li>标识，由原始发送方设置，在目的地依据标识区分组</li>
<li>分片偏移，表示分片中数据的第一个字节在原数据报的偏移量（<strong>8个字节为单位</strong>）</li>
<li>更多分片（MF），0表示最后一个分片，否则为1。</li>
</ul>
<p>偏移的具体内容如下图所示：</p>
<p><img src="https://i.imgur.com/PHFhggZ.jpg" alt=""></p>
<p>第二个数据报偏移为185*8=1480=第一个分片负载，即在第一个分片零偏移的基础上偏移了185个单位。</p>
<p>当TCP报文段的一个分片丢失了，TCP会重传整个报文段，而重传一个分片是不可能的，因为在路径路由器可以分片数据报，源主机是不清楚数据报如何被分片的。</p>
<ul>
<li>具有更大偏移量的分片要比第一个分片更优先投递，这样有利于接收主机确定所需的缓存空间最大值</li>
<li>收到任何一个分片，IP层就启动计时器，超时即丢弃数据报。</li>
<li>UDP数据报长度有限，满额数据报并不能很好的被投递<ul>
<li>本地协议实现的限制</li>
<li>接受应用程序并没有做好准备接收处理这么大的数据报</li>
</ul>
</li>
</ul>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/13/用户数据报和IP分片/" data-id="ck0rl0gx2001syswiquqsijf0" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-广播和本地组播（IGMP和MLD）" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/广播和本地组播（IGMP和MLD）/">广播和本地组播（IGMP和MLD）</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/12/广播和本地组播（IGMP和MLD）/" class="article-date"><time datetime="2018-04-12T12:46:25.000Z" itemprop="datePublished">2018-04-12</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>距离项目开启已经过去了一段时间，这段时间内自己学习的内容也算挺多的，但是也较容易遗忘，之后应该在空余的时间内多翻翻博客，更加清楚传统计算机网络的运作。</p>
<p>由于51要出去玩，更要好好利用好最近的时间。完成自己的每周规划。</p>
<p>并且考虑到最近身体比较虚弱…，应该更加早睡早起!</p>
<p>加油！</p>
<h1 id="广播和本地组播（IGMP和MLD）"><a href="#广播和本地组播（IGMP和MLD）" class="headerlink" title="广播和本地组播（IGMP和MLD）"></a>广播和本地组播（IGMP和MLD）</h1><p>在引言中有下面一些比较重要的概念：</p>
<p>广播和组播为应用程序提供了两种服务</p>
<ul>
<li>数据分组交付至多个目的地 //顾名思义</li>
<li>通过客户端请求/发现服务器  //类似于DHCP</li>
</ul>
<p>一个广播请求会影响在广播范围内所有可以到达的主机，而组播只影响那些可能对该请求有<strong>兴趣</strong>的主机</p>
<p>注意，在广播的更高开销和简单性以及组播的效率改善和更多的复杂性之间存在一种平衡。</p>
<hr>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><p>广播是指将报文发送到网络中的所有可能的接收者。很容易的能够理解广播的概念，就像你拿着大喇叭对所有人喊话一样。所以它并不需要ARP请求来确定每个目的地的MAC地址。</p>
<p>一般而言，使用广播的应用程序使用UDP协议，然后调用一组普通的API来发送流量。并且我们在打算发送广播数据报的时候，要加上一些特殊的标志，这样确认后可以防止误操作而产生大量的广播流量，造成网络拥塞。</p>
<hr>
<h2 id="组播"><a href="#组播" class="headerlink" title="组播"></a>组播</h2><p>组播的意思就是向一个组发送流量。</p>
<p>组播状态必须由主机和路由器来保持，定期的进行更新和删除操作，这样就能够很好的维护一个组。那他是如何更新的呢？我们下面的协议会讲到~</p>
<h2 id="主机地址过滤"><a href="#主机地址过滤" class="headerlink" title="主机地址过滤"></a>主机地址过滤</h2><p>过滤发生在每个主机的网络接口卡（NIC）上，</p>
<p>NIC指接收目的地址是接口的硬件地址或者广播地址的那些帧，如果涉及到组播帧，情况会更复杂。它往往被分成两类：</p>
<ul>
<li>执行基于组播硬件地址的散列值的过滤 //存在散列冲突</li>
<li>侦听组播地址的一张有限表 //超过表所能容纳的更多组播地址时，NIC进入“组播混杂”模式，即所有的流量都会交给主机软件。</li>
</ul>
<p>组播地址和48位的硬件地址的映射是不唯一的，所以进一步的过滤还是必须的。</p>
<p>这两种类型说到底还是会有一些不必要的数据报被接受，所以还需要设备驱动程序或者高层软件执行检查。</p>
<p>如下图所示：</p>
<p><img src="https://i.imgur.com/Lvq25ku.jpg" alt=""></p>
<p>当NIC接收到帧的时候，它首先会检查是否接收该帧（即检查CRC，MAC地址等)，然后交付给设备驱动程序,设备驱动程序查明该帧的类型，例如IP数据包，他就传递到IP层。IP层过滤完成后，便传到TCP或UDP等。然后就查询端口号。其实就是数据报在Internet主机上分解的过程， 如下图：</p>
<p><img src="https://i.imgur.com/S2Bb36o.jpg" alt=""></p>
<hr>
<h2 id="互联网组管理协议和组播侦听发现协议"><a href="#互联网组管理协议和组播侦听发现协议" class="headerlink" title="互联网组管理协议和组播侦听发现协议"></a>互联网组管理协议和组播侦听发现协议</h2><p>两个协议都用于允许组播路由器了解附近主机感兴趣的组，区别在于IPv4使用的是互联网组管理协议（<strong>IGMP</strong>),而IPV6使用的是组播帧听发现协议（<strong>MLD</strong>）</p>
<p><strong>如何运作</strong>：</p>
<p>组播路由器定期向每个连接的子网发送IGMP(MLD)请求。主机则会响应这个请求，告诉路由器那些组和源是感兴趣的。如果成员资格变动，主机也可以发送主动提供的报告。</p>
<p><img src="https://i.imgur.com/61zmHsM.jpg" alt=""></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/12/广播和本地组播（IGMP和MLD）/" data-id="ck0rl0gwo001iyswi515r5e57" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-Internet控制报文协议" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/10/Internet控制报文协议/">Internet控制报文协议</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/10/Internet控制报文协议/" class="article-date"><time datetime="2018-04-10T12:46:25.000Z" itemprop="datePublished">2018-04-10</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>首先，我们必须先清楚，IP协议本身没有为终端系统提供直接的方法来发现那些<strong>发往目的地址失败的IP数据包</strong>，并且IP没有提供<strong>直接</strong>的方式来获取诊断信息，那么我们的故事来了。</p>
<p>Internet控制报文协议（ICMP）腾空而出，与IP结合使用，提供了与IP协议层配置和IP数据包处置相关的诊断和控制信息，即<strong>它负责传递可能需要注意的差错和控制报文</strong>。ICMP表明了某些类别的故障和配置信息，但是并不为IP网络提供可靠性。</p>
<p>注意：我们常见的丢包（<strong>路由器缓冲区溢出</strong>）并不会触发任何的ICMP信息。</p>
<hr>
<h2 id="在IPv4和IPv6中的封装"><a href="#在IPv4和IPv6中的封装" class="headerlink" title="在IPv4和IPv6中的封装"></a>在IPv4和IPv6中的封装</h2><p><strong>ICMP报文是在IP数据包内被封装传输的。</strong></p>
<p>如图所示：</p>
<p><img src="https://i.imgur.com/e7WLHxu.jpg" alt=""></p>
<p>ICMP报文封装在IPv4和IPv6的内部，即在其头部后面。ICMP头部包含了<strong>整个</strong>ICMP数据段的校验和。</p>
<p>下图表示了报文的格式</p>
<p><img src="https://i.imgur.com/fgyoLuM.jpg" alt=""></p>
<p>我们可以了解到：</p>
<ul>
<li>类型字段长8位，ICMPv4为其保留42个值，但是只有8个常用，下文会提到。</li>
<li>代码字段长8位，每个类型有不同的代码，代表不同的含义</li>
<li>校验和长16位，涵盖了整个报文</li>
</ul>
<p>如果一个ICMP报文校验和错误，显然是要被丢弃的；</p>
<p>同时<strong>这边给出中文版一个蹩脚的翻译</strong> ：没有ICMP报文可以表示收到的ICMP报文中的校验和是错误的。 原版本的翻译是： <strong>there is no ICMP message to indicate a bad checksum in a received ICMP message</strong>，较为顺口的翻译应该是，在收到的ICMP报文中没有指示校验和错误的ICMP报文，即ICMP的报文不会去指错另一个ICMP的报文。</p>
<h2 id="ICMP报文"><a href="#ICMP报文" class="headerlink" title="ICMP报文"></a>ICMP报文</h2><p>ICMP报文可以分为两大类：</p>
<ul>
<li>有关IP数据包传递的ICMP报文（<strong>差错报文</strong>）</li>
<li>有关信息采集和配置的ICMP报文（<strong>查询或信息类报文</strong>）</li>
</ul>
<p>信息类报文包括回显请求和回显应答，以及路由器通告和路由器请求。</p>
<p>最常见的差错报文类型包括目的不可达，重定向，超时，和参数问题。</p>
<p> <strong>关于类型字段以及类型所使用的代码号表格在书本250页均有，这边不再强调</strong></p>
<p>下面进一步讨论差错报文常用的类型：</p>
<h3 id="目的不可达（ICMPv4类型3，ICMPv6类型1）和数据包太大（ICMPv6类型2）"><a href="#目的不可达（ICMPv4类型3，ICMPv6类型1）和数据包太大（ICMPv6类型2）" class="headerlink" title="目的不可达（ICMPv4类型3，ICMPv6类型1）和数据包太大（ICMPv6类型2）"></a>目的不可达（ICMPv4类型3，ICMPv6类型1）和数据包太大（ICMPv6类型2）</h3><p>目的不可这种类型的报文用来<strong>表示数据包无法送达目的地</strong>，其<em>主要</em>可细分成：</p>
<ul>
<li>主机不可达（ICMPv4代码1）和地址不可达（ICMPv6代码3）<ul>
<li>由路由器或主机产生，直接交付的时候由于某种原因无法到达目的地，例如主机关闭</li>
</ul>
</li>
<li>目的无路由（ICMPv6代码0）<ul>
<li>出现在到达数据包不必采用直接交付的方式来转发，但没有路由条目指定下一跳路由地址</li>
</ul>
</li>
<li>管理禁止通信（ICMPv4代码3）和目的管理禁止通信（ICMPv6代码1）<ul>
<li>通常是防火墙故意丢弃流量导致</li>
</ul>
</li>
<li>端口不可达（ICMPv4代码3）和端口不可达（ICMPv6代码4）<ul>
<li>当传入数据报的目的应用程序还没有准备好接收，就生成端口不可达报文</li>
</ul>
</li>
</ul>
<p>数据包太大（<strong>PTB</strong>）：</p>
<p>如果一个IPv4路由器收到一个数据报大于选定的传出网络接口的<strong>MTU</strong>， 则其需要分片，但如果IP头部设置了不分片位字段，则其被丢弃。同时，产生<strong>ICMPv4目的不可达（PTB）报文</strong>，该报文能将下一跳的MTU包含在其中。</p>
<p><img src="https://i.imgur.com/FfssSrL.jpg" alt=""></p>
<p>而在ICMPv6中，因为IPv6只有数据包的发送者才能执行数据包分片，所以只产生<strong>ICMPv6目的不可达（PTB）报文</strong>，该报文能将下一跳的MTU包含在其中。</p>
<hr>
<h3 id="重定向（ICMPv4类型5，ICMPv6类型137）"><a href="#重定向（ICMPv4类型5，ICMPv6类型137）" class="headerlink" title="重定向（ICMPv4类型5，ICMPv6类型137）"></a>重定向（ICMPv4类型5，ICMPv6类型137）</h3><p>当路由器收到一个来自主机的不是给自己的数据报时，转发数据报到下一跳更好的路由，同时，<strong>路由器发送一个重定位报文到主机</strong>，使其更新路由表，这样下一次数据报直接就会到新定义的节点上。如图所示：</p>
<p><img src="https://i.imgur.com/AYg2S5j.jpg" alt=""></p>
<p>重定向报文包含了数据报下一跳正确路由器的IPv4地址。如图</p>
<p><img src="https://i.imgur.com/lMhBvzi.jpg" alt=""></p>
<h3 id="超时（ICMPv4类型11，ICMPv6类型3）"><a href="#超时（ICMPv4类型11，ICMPv6类型3）" class="headerlink" title="超时（ICMPv4类型11，ICMPv6类型3）"></a>超时（ICMPv4类型11，ICMPv6类型3）</h3><p>当由于TTL或跳数限制字段值调小致使路由器丢弃报文时，产生ICMP超时报文</p>
<p><strong>一个工具</strong>：traceroute工具，被用于确定发送者到目的地路径上的路由器。</p>
<p>工作方式：</p>
<ol>
<li>TTL置1</li>
<li>发送数据报，接收路由器的ICMP超时报文，如果该路由为最终路由则停止。</li>
<li>TTL+=1</li>
<li>转回第二步</li>
</ol>
<h3 id="参数问题（ICMPv4类型12，ICMPv6类型4）"><a href="#参数问题（ICMPv4类型12，ICMPv6类型4）" class="headerlink" title="参数问题（ICMPv4类型12，ICMPv6类型4）"></a>参数问题（ICMPv4类型12，ICMPv6类型4）</h3><p>当一个主机或者路由器接收到一个IP数据报，其IP头部存在不可修复的问题时就会产生一个ICMP参数问题报文。一个特殊的参数报文<strong>指针</strong>字段只是了错误字段相对于出错的IP头部的偏移值。</p>
<hr>
<p>下面进一步讨论信息类报文常用的类型：</p>
<h3 id="回显请求-应答（ping）（ICMPv4类型0-8，ICMPv6类型129-128）"><a href="#回显请求-应答（ping）（ICMPv4类型0-8，ICMPv6类型129-128）" class="headerlink" title="回显请求/应答（ping）（ICMPv4类型0/8，ICMPv6类型129/128）"></a>回显请求/应答（<strong>ping</strong>）（ICMPv4类型0/8，ICMPv6类型129/128）</h3><p>原理，收到ICMP回显请求报文后，ICMP要求将任何接收到的数据返回给发送方。报文格式如下</p>
<p><img src="https://i.imgur.com/VVAfnaA.jpg" alt=""></p>
<p>其中，<strong>标识符字段</strong>可以让发送主机利用，借此分离返回的应答。</p>
<p>当一个ping实例运行的时候，序列号从0开始，每发送一个回显请求报文便加1.<br>ping打印出每个返回的数据报的序列号，方便用户查看数据报是否丢失等。</p>
<h3 id="路由器发现：路由器请求RS和通告RA（ICMPv4类型9，10）"><a href="#路由器发现：路由器请求RS和通告RA（ICMPv4类型9，10）" class="headerlink" title="路由器发现：路由器请求RS和通告RA（ICMPv4类型9，10）"></a>路由器发现：路由器请求RS和通告RA（ICMPv4类型9，10）</h3><p>首先<strong>定期</strong>使用TTL=1，对本地网络的所有主机组播（224.0.0.1）。使用RS报文发送到所有路由器组播地址（224.0.0.2），路由器发现的主要目的是让一台主机学习到它所在本地子网中的所有路由器，这样让他选好出一个默认的路由。</p>
<hr>
<h2 id="处理ICMP报文"><a href="#处理ICMP报文" class="headerlink" title="处理ICMP报文"></a>处理ICMP报文</h2><p>传入的信息类请求将被<strong>操作系统自动处理</strong>，而差错类报文<strong>传递给用户进程或传输层协议</strong>。</p>
<p>特例：重定向报文将导致主机路由表中的自动更新，目的不可达报文用于路径MTU发现机制（PMTUD）。这一般由传输层协议来实现。</p>
<h2 id="ICMP差错报文"><a href="#ICMP差错报文" class="headerlink" title="ICMP差错报文"></a>ICMP差错报文</h2><p>限制生成的ICMP差错报文的元婴是限制生成所谓的广播风暴，ICMPv4有以下情况：</p>
<ul>
<li>ICMPv4差错报文</li>
<li>目的地址是IPv4广播或组播地址</li>
<li>作为链路层的广播数据报</li>
<li>不是第一个分片的其他分片</li>
<li>源地址为环回地址，广播或组播地址，零地址。</li>
</ul>
<p>ICMPv6有以下情况：</p>
<ul>
<li>ICMPv6差错报文</li>
<li>ICMPv6重定向报文</li>
<li>目的地址是IPv6的组播地址数据报（除PTB和参数问题报文）</li>
<li>链路层广播组播的数据包</li>
<li>源地址为未指定或组播地址，<em>或者任意为发送者所致的选播地址</em>。</li>
</ul>
<p><strong>限制ICMP报文数据的方法是使用令牌桶</strong><br>每个桶保留最大数量的令牌，每个令牌允许一定数量的报文被发送。<strong>桶定期被新的令牌填充</strong>。每发送一个报文就减一，</p>
<p>一个概念：<strong>当发送一个ICMP差错报文的时候，它包含了一个完整的源自“违规”或者“原始”数据包的IP头部副本，再加上原始数据报的IP有效载荷区中的任何其他数据。</strong></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/10/Internet控制报文协议/" data-id="ck0rl0gvh000ayswircqgusaw" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-Internet协议" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/07/Internet协议/">Internet协议</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/07/Internet协议/" class="article-date"><time datetime="2018-04-07T02:47:47.000Z" itemprop="datePublished">2018-04-07</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>写在开头：</p>
<p>埋头学习也差不多半个月了，达到了这半个月每天都会去图书馆的目标。确实挺忙的，不管在学习上，部门社团上，党建上。有时候为了多学一些总是会挤掉了其他事情的一些时间。但是自己时刻提醒着自己不要太过激进了，做好自己的本职工作，生活还是要继续的，协调好彼此之间的关系。希望自己还是像以前那样开心就好了。</p>
<p>加油!</p>
<h1 id="Internet协议"><a href="#Internet协议" class="headerlink" title="Internet协议"></a>Internet协议</h1><p>IP是TCP/IP协议族中的核心协议。IP提供了一种<strong>尽力而为</strong>，<strong>无连接</strong>的数据报交付服务。</p>
<p><strong>尽力而为</strong>的含义是不保证IP数据报能成功到达目的地。任何的可靠性必须靠上层（例如TCP）提供</p>
<p><strong>无连接</strong>意味着IP不维护网络单元（即路由器）中数据报相关的任何链接状态，这也就意味着IP数据报可不按照顺序交付，每个数据报可以独立路由，通过不同的路径，并且有可能较靠后发送的数据报提前到达</p>
<hr>
<h2 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h2><p>一个32位值的4字节按以下顺序传输：首先是 0 ~ 7 位，然后8~15位，16~23，23~31位。这就是所谓的高位有限字节序，又称网络字节序。它是TCP/IP头部中所有二进制整数在网络中传输时所使用的字节顺序。</p>
<hr>
<p>下面给出IPv4头部细节</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>版本</td>
<td>包含IP数据报的版本字段</td>
</tr>
<tr>
<td>IHL</td>
<td>长4位，表示IPv4头部中32位的数量，即IHL值为x，头部长度就为32*x</td>
</tr>
<tr>
<td>DS</td>
<td>区分服务字段</td>
</tr>
<tr>
<td>ECN</td>
<td>显式拥塞通知</td>
</tr>
<tr>
<td>总长度字段</td>
<td>表示IPv4数据报的总长度，通过它和IHL就可以知道数据报的数据部分的位置</td>
</tr>
<tr>
<td>标识</td>
<td>表示IPv4主机发送的数据报，能够避免数据报分片混淆</td>
</tr>
<tr>
<td>生存期TTL</td>
<td>用于设定一个数据报可经过的路由器的数量上限</td>
</tr>
<tr>
<td>协议</td>
<td>表示数据报有效载荷部分的数据类型。，常见的有17（UDP)\6(TCP)</td>
</tr>
<tr>
<td>头部校验和</td>
<td>注意它仅计算IPv4的头部</td>
</tr>
<tr>
<td>源IP地址和目的IP地址</td>
<td>通常标识一台计算机的一个接口</td>
</tr>
</tbody>
</table>
<p><strong>TTL</strong>：生存期，发送方发送时会将它设位一个值，每次经过一台路由器就会减一，显然当这个值等于0的时候，数据报就会被丢弃。这样就可以避免了数据报有可能在路由器的环路中无限循环下去的问题。</p>
<hr>
<h2 id="Internet校验和"><a href="#Internet校验和" class="headerlink" title="Internet校验和"></a>Internet校验和</h2><p>Internet校验和是一个16位的数字和。</p>
<hr>
<h2 id="IP转发"><a href="#IP转发" class="headerlink" title="IP转发"></a>IP转发</h2><p>我们知道，IP协议可以接收到一个来自自己主机或者网络接口的数据报。IP层包括了一些位于内存中的信息，通常称为路由表或者<strong>转发表</strong></p>
<p>转发数据的时候，IP模块会先检查数据报的地址是不是自己的IP地址（这个地址可以很多，比如组播，广播地址），是的话就给上头（数据报头部指定的协议模块），不是的话：</p>
<ul>
<li>如果IP层被设置成路由器，就查找转发表，转发到下一跳</li>
<li>否侧就扔了</li>
</ul>
<p>转发表里有下面几样东西：</p>
<ul>
<li>目的地</li>
<li>掩码</li>
<li>下一跳：下一个IP的地址~</li>
<li>接口：即下一跳的网络接口</li>
</ul>
<p>IP转发只是提供数据报发送的下一跳实体的IP地址，它假设下一跳比执行转发的系统更接近目的地。</p>
<hr>
<p>附上<a href="http://www.cnblogs.com/ZCplayground/p/8424916.html" target="_blank" rel="noopener">畅畅酱关于这个章节的地址</a></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/07/Internet协议/" data-id="ck0rl0gvb0007yswikdd2x0gu" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-SDN第一次作业问题" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/SDN第一次作业问题/">SND上机作业中出现的一些问题</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/06/SDN第一次作业问题/" class="article-date"><time datetime="2018-04-06T12:46:25.000Z" itemprop="datePublished">2018-04-06</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>首先给出链接</p>
<ul>
<li><a href="http://www.zdfans.com/5928.html" target="_blank" rel="noopener">VMware安装</a></li>
<li><a href="http://www.cnblogs.com/qq952693358/p/5860101.html" target="_blank" rel="noopener">mininet安装</a></li>
<li><a href="https://www.sdnlab.com/19189.html" target="_blank" rel="noopener"> floodlight安装及问题，各个版本Ubuntu</a></li>
<li><a href="http://www.cnblogs.com/easteast/p/7920316.html" target="_blank" rel="noopener">SDN第一次上机作业</a></li>
</ul>
<p>如果在这些链接的基础上你已经能很好的完成SDN第一次上机作业，那么下面的东西你也就没必要看了~</p>
<p>我是按照教程的顺序一步一步写下来的~</p>
<hr>
<h1 id="我们使用Ubuntu16"><a href="#我们使用Ubuntu16" class="headerlink" title="我们使用Ubuntu16"></a>我们使用Ubuntu16</h1><h2 id="安装mininet时候出现问题"><a href="#安装mininet时候出现问题" class="headerlink" title="安装mininet时候出现问题"></a>安装mininet时候出现问题</h2><p>当我执行<code>sudo apt-get update</code>时有以下的错误</p>
<p><img src="SDN第一次作业问题/运行update出现问题.jpg" alt=""></p>
<p>解决方法</p>
<p><code>sudo pkill -KILL appstreamcli</code></p>
<p> <code>wget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.deb</code></p>
<p><code>sudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb</code></p>
<p><code>sudo apt-get update</code></p>
<p><a href="https://askubuntu.com/questions/774986/appstreamcli-hanging-with-100-cpu-usage-during-update" target="_blank" rel="noopener">参考资料</a></p>
<p>然后便可以成功运行。</p>
<p><code>sudo apt-get upgrade</code>在这种情况下仍可能出现一些小瑕疵，我们暂时不管。</p>
<hr>
<h2 id="第二部分实验内容出现的问题"><a href="#第二部分实验内容出现的问题" class="headerlink" title="第二部分实验内容出现的问题"></a>第二部分实验内容出现的问题</h2><p>然后我们就会一路顺畅的走下来，在第二个实验作业中，提示我们<code>mininet must run as root</code>如图</p>
<p><img src="SDN第一次作业问题/mininet run as root.jpg" alt=""></p>
<p>显然我们要在root下运行mininet的图形界面。</p>
<p>为此，我们输入<code>su -</code> 及密码，但是并不能进入root。原因是root用户还没有设置密码，所以我们输入以下指令<code>sudo passwd</code> 设置密码。此后我们便很顺利的完成第二部分的实验内容。</p>
<hr>
<h2 id="floodlight与mininet结合出现的问题"><a href="#floodlight与mininet结合出现的问题" class="headerlink" title="floodlight与mininet结合出现的问题"></a>floodlight与mininet结合出现的问题</h2><p>我们根据教程一路做下来，如果提示我们什么指令没有安装，就根据提示安装对应的指令，例如 <code>ant`</code>vim<code>指令没有安装，下图为</code>ant`指令没有安装的实例</p>
<p><img src="SDN第一次作业问题/ant指令没有按照.jpg" alt=""></p>
<p>如果你使用的时14版本，这里给出教程中设置变量的一个拼写错误</p>
<p><img src="SDN第一次作业问题/floodlight教程问题.jpg" alt=""></p>
<p>接下来就是进行实验的部分了，如果你很惨，没有找到胖树（fattree.py)这个文件，你只好自己去复制粘贴脚本了~<strong>在此之前你最好多多了解下vim文本的操作指令。</strong></p>
<p>当你写好脚本的时候，别忘了把它生成可执行文件 <code>chmod +x fattree.py</code>  </p>
<p><strong>注意：如果你的脚本里含有中文，可能是会报错的</strong></p>
<p><em>因为某种原因，我没有采用screen mn …..的操所，而是直接sudo它</em></p>
<p>并且在执行脚本中不能够连接上控制器，或者连接控制器后pingall依然是没有连接控制的现象的时候（听起来有点绕口，如果你出现这种问题，你可能会大致清楚我要表达的意思）</p>
<p>根据<strong><a href="https://home.cnblogs.com/u/qq952693358" target="_blank" rel="noopener">Wasdns</a></strong>的方法，对脚本中的参数做了以下的修改。</p>
<p><img src="SDN第一次作业问题/脚本修改.jpg" alt=""></p>
<p>最后你就可以欢快的完成你的实验作业了</p>
<p><img src="SDN第一次作业问题/sdn第二个实验结果.jpg" alt=""><br><img src="SDN第一次作业问题/fattree.jpg" alt=""></p>
<hr>
<p>经历了断断续续安装学习的几天，耐心是很重要的，安装过程的一些毛病不能够忽视，阅读提示很重要，并且根据提示去解决问题。</p>
<p>终于在经历了6台虚拟机的折磨后，在写博客的最后这一台很好的完成了任务。MUA！</p>
<p>感谢实验室的伙伴们提供的宝贵经验~</p>
<p>感谢实验室的伙伴们提供的宝贵经验~</p>
<p>感谢实验室的伙伴们提供的宝贵经验~</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/06/SDN第一次作业问题/" data-id="ck0rl0gw1000pyswi5eygu62g" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SDN/">SDN</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-系统配置：DHCP和自动配置" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/05/系统配置：DHCP和自动配置/">系统配置：DHCP和自动配置</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/05/系统配置：DHCP和自动配置/" class="article-date"><time datetime="2018-04-05T02:47:47.000Z" itemprop="datePublished">2018-04-05</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>写在开头：今天和导师见了个面，抛给我一堆材料以及论文，感觉自己学业更加繁重。有些知识现阶段我可能没办法掌握，但是至少在我需要进一步理解它的时候，要知道在哪个地方能够找到。努力协调好项目以及导师的安排，课堂的内容尽量都在课堂直接消化了。找到能够一起学习的伙伴们是多门幸运的事情，好好加油~</p>
<p>Yesterday you said tomorrow.</p>
<hr>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们知道每台主机和路由器都是需要一定的配置的信息的，配置信息用于为系统指定本地名称，以及接口制定标识符（比如IP地址）,而在TCP/IP网络中。每个接口需要：  </p>
<ul>
<li>IP地址</li>
<li>子网掩码</li>
<li><p>广播地址</p>
<p>系统需要一个路由或转发表，用来确定到达不同目的地的系统通讯。</p>
</li>
</ul>
<p>Internet客户端主机中用于建议基本要素的协议和程序：<strong>动态主机配置协议（DHCP）</strong>以及IPv4和IPv6的无状态地址自动配置。</p>
<p>状态机：状态机由状态寄存器和组合逻辑电路构成，能够根据控制信号按照预先设定的状态进行状态转移，是协调相关信号动作，完成特定操作的控制中心。</p>
<h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>DHCP是一种流行的客户机/服务器协议，它用于为主机（或路由器）指定配置信息。</p>
<p><em>DHCP的设计是基于一种早期的协议，Internet引导程序协议（BOOTP），只不过它已经过时了…</em></p>
<p>DHCP由两个主要的部分组成，地址管理和配置数据交付。</p>
<p>地址管理用于IP地址的动态分配，并为客户机提供地址租用。<br>配置数据交付包过DHCP协议的消息格式和状态机</p>
<p>DHCP服务器可配置提供三种地址分配：</p>
<ul>
<li>自动分配，同动态分配，但是地址不可撤销</li>
<li>动态分配，最常用，客户机从服务器配置的地址池中获得一个可撤销的IP地址</li>
<li>手动分配，</li>
</ul>
<hr>
<h2 id="地址池和租用"><a href="#地址池和租用" class="headerlink" title="地址池和租用"></a>地址池和租用</h2><p>在动态分配中，DHCP客户机请求分配一个IP地址，服务器从可用的地址池中选择一个地址作为响应。</p>
<p>分配给客户机的地址只在一段特定时间内有效，这段时间称为<strong>租用期</strong></p>
<p><strong>运作</strong>：<br>当发送DHCP请求时，客户机需要向服务器提供信息。这些信息包过客户机的名称、请求的租用期、已使用或最后使用过的地址副本和其他参数。  </p>
<p>当服务器接收到这个请求时，它可利用客户机提供的信息（包过MAC地址请求)，结合其他从外部获得的信息（例如一天的时间，接受请求的接口），决定在响应中提供的地址和配置信息。</p>
<p>当服务器向客户机提供租用期时，服务器将租用信息保存在持久性的存储器（非易失性内存或磁盘）中。</p>
<hr>
<h2 id="DHCP消息格式"><a href="#DHCP消息格式" class="headerlink" title="DHCP消息格式"></a>DHCP消息格式</h2><p>我们知道 DHCP前身是BOOTP，所以它的消息格式是采用拓展BOOTP的方式</p>
<p>如图所示：</p>
<p><img src="https://i.imgur.com/4GjVSCd.jpg" alt=""></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>内容及作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Op</td>
<td>标识消息是请求（1），还是应答（2）</td>
</tr>
<tr>
<td>htype</td>
<td>基于ARP使用的值，（1）为以太网</td>
</tr>
<tr>
<td>hlen</td>
<td>存放硬件（MAC)地址</td>
</tr>
<tr>
<td>跳步</td>
<td>用于保存消息传输过程中的中继次数，初始为0，依次增加</td>
</tr>
<tr>
<td>事务ID <em>xid</em></td>
<td>客户机选择的随机数，服务器需要将它复制在应答中，用于匹配应答与请求</td>
</tr>
<tr>
<td>秒数</td>
<td>申请地址经过的秒数</td>
</tr>
<tr>
<td>标志</td>
<td>广播标志，表示客户机所发请求不能处理单播IP数据报，但能处理广播数据报</td>
</tr>
<tr>
<td>客户机IP地址</td>
<td>请求者的IP地址，如果没有就为0</td>
</tr>
<tr>
<td>你的IP地址，yiaddr</td>
<td>即服务器地址</td>
</tr>
<tr>
<td>下一服务器IP地址</td>
<td>顾名思义客户机可能需要另一个DHCP服务器来完成它的请求</td>
</tr>
<tr>
<td>网关IP地址</td>
<td>中继地址，由DHCP中继器填写，在转发时返回自己的地址</td>
</tr>
<tr>
<td>客户机硬件地址</td>
<td>客户机唯一标识符</td>
</tr>
</tbody>
</table>
<p>其他字段例如<em>服务器名，引导文件名</em>并不是每次都需要填写的，但是<strong>选项字段</strong>区分DHCP和传统BOOTP消息。</p>
<p>因此我们可以称<strong>DHCP消息是带有一组特殊选项的BOOTP消息</strong>，至于选项的细节，我们在这里暂时不提</p>
<hr>
<h2 id="DHCP协议操作"><a href="#DHCP协议操作" class="headerlink" title="DHCP协议操作"></a>DHCP协议操作</h2><p>当新客户机连接网络时，它首先发现DHCP服务器们以及服务器们能提供的地址。然后它向中意的服务器发送它中意的请求，<em>同时也向其他服务器发送它的决定</em>。如果该服务器还保留该地址，便通过确认将地址分配给客户机。</p>
<p><img src="https://i.imgur.com/zXCl1pN.jpg" alt=""></p>
<p>他们之间的互相通讯可以由上图反应，数据包中各单位值的修改我暂时没有写在这里。</p>
<p><strong>这里存在一个疑问</strong>，DHCP服务器如何向一个没有设置IP地址的客户机传达消息呢？</p>
<p>还记得数据报中的标志字段吗？设置标志字段表示自己能够接收广播数据报，所以DHCP服务器是采用广播的方式连上客户机的</p>
<p>下图给出DHCP的状态机</p>
<p><img src="https://i.imgur.com/fb6Mgc3.jpg" alt=""></p>
<hr>
<h2 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h2><p>在更复杂的网络中，可以通过DHCP中继代理来中继DHCP流量，这样会更方便~</p>
<p><img src="https://i.imgur.com/YcjAYZI.jpg" alt=""></p>
<p>如图，在网段A\B之间的中继器会转发DHCP消息。通过选项或者填充空白字段使用额外的消息来标识它。</p>
<p>这里有个要注意的地方，中继一般不会参与到客户机与服务器的所有流量交换。它仅中继客户机首次广播的消息，当客户机获得了服务器的IP地址，那就可以直接与服务器单播通讯了。</p>
<h3 id="中继代理信息选项（RAIO）"><a href="#中继代理信息选项（RAIO）" class="headerlink" title="中继代理信息选项（RAIO）"></a>中继代理信息选项（RAIO）</h3><p>定义了很多子选项，例如几个被ISP用于标识一个请求来自哪个用户、链路或网络的选项</p>
<p>例如：中继代理远程ID子选项和IPv6远程ID选项</p>
<p>用于标识发送请求的DHCP客户机的方法。通俗来说就是采用本地解释的命名方式，例如呼叫方ID、用户名、调制解调器ID、点到点链路的远程IP地址等</p>
<h2 id="DHCP和DNS交互"><a href="#DHCP和DNS交互" class="headerlink" title="DHCP和DNS交互"></a>DHCP和DNS交互</h2><p>当一台DHCP客户机获得一个IP地址时，它接收的配置信息的重要部分是一台DNS服务器的IP地址。</p>
<p>组合DHCP/DNS服务器或动态DNS用来实现指定DHCP地址与相应的DNS地址的映射更新方法。</p>
<p>组合DHCP/DNS服务器可读取请求中的客户机标识符或域名，在ACK进行响应前，通过映射更新内部DNS数据库，这样在后续的DNS请求中，能够在客户机名称和新分配的IP地址之间转换</p>
<h2 id="以太网上的PPP"><a href="#以太网上的PPP" class="headerlink" title="以太网上的PPP"></a>以太网上的PPP</h2><p>对于大多苏局域网和一些广域网连接，DHCP提供了最常见的客户机系统配置的方法。对于广域网连接，常用另一种基于PPP的方法替代它。这种方法设计在以太网中携带PPP，因此称为以太网上的PPP（<strong>PPPoE</strong>）</p>
<p>PPPoE用于广域网连接设备（例如图中的DSL调制解调器）作为一个交换机或网桥而不是使用路由器的情况下。</p>
<p><img src="https://i.imgur.com/7EySPFL.jpg" alt=""></p>
<p>在DSL调制解调器与ISP成功建立一条底层链路后，PC就可以开始PPPoE交换</p>
<p>PPPoE消息交换开始于发现阶段及建立PPP会话阶段。每个消息是一个PAD（主动发现）消息。PADI（初始化）请求来自PPPoE服务器的响应，PADO(提供）提供连接。PADR(请求）表示客户机可以从多个可能的服务器中做出选择。PADS（会话确认）从选中的服务器向客户机提供一个确认。经过PAD交换，一次PPP会话开始。</p>
<p>PPP会话可以由任何一方发送PADT(终止）消息来终止，或在底层链路出现故障时关闭。</p>
<p><img src="https://i.imgur.com/gcxBE3E.jpg" alt=""></p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/05/系统配置：DHCP和自动配置/" data-id="ck0rl0gx4001wyswi6n874fu2" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-防火墙和网络地址转换" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/03/防火墙和网络地址转换/">防火墙和网络地址转换</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/04/03/防火墙和网络地址转换/" class="article-date"><time datetime="2018-04-03T02:47:47.000Z" itemprop="datePublished">2018-04-03</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>写在开头：在我正在打这篇博客的时候，畅畅哥跟我讲了下前面写的博客有些需要懂的地方没有去弄懂。想想这几天看书，确实多了几分急躁，时间还久着，就像畅畅哥说的“我们高屋建瓴地来”。我得沉下心来，完整的弄懂这些个内容，后面才不会慌忙。</p>
<p>所以清明的时间，我应该先停下进度，回顾一个前面所学的内容，该懂的弄懂了，被忽视的重视了。在写博客的时候，应该给出自己的一些总结，那才是属于自己的真正的东西。</p>
<h1 id="防火墙和网络地址转换"><a href="#防火墙和网络地址转换" class="headerlink" title="防火墙和网络地址转换"></a>防火墙和网络地址转换</h1><p>防火墙：一种能解决限制所发送的流量类型的路由器</p>
<p>NAT：网络地址转换</p>
<hr>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>最为常用的两种防火墙是代理防火墙和包过滤防火墙。</p>
<p>他们之间主要区别是所操作的协议栈的层次及由此决定的IP地址和端口号的使用。包过滤防火墙是一个互联网路由器，能够丢弃符合（或者不符合）特定条件的数据包。</p>
<h3 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h3><p>包过滤防火墙作为互联网路由器，能够过滤（丢弃）一些网络流量，他们一般都可以配置为丢弃或转发数据包头中符合（或者不符合）特定标准的数据包，这些标准称为过滤器。</p>
<p><img src="https://i.imgur.com/dnSGFy9.jpg" alt=""></p>
<p>一个典型的包过滤防火墙有三个网络接口的互联网路由器：一个“内”接口，一个“外”接口和第三个“非军事区”（DMZ）接口。通常情况下，过滤器会全力拦截来自外网的恶意。但是不会限制从内网到外网的流量。</p>
<h3 id="代理防火墙"><a href="#代理防火墙" class="headerlink" title="代理防火墙"></a>代理防火墙</h3><p>本质上是运行一个或多个应用层网关的主机，它拥有很多网络接口，能够在应用层中连接/关联之间的特定类型的流量。</p>
<p><img src="https://i.imgur.com/I8HVRov.jpg" alt=""></p>
<p>如上图所示，内部网络外出连接在防火墙上终止，外部Internet进去连接只到运行的委托代理。而在中间这堵墙（代理防火墙）上运行的是每个受支持的服务的应用/服务代理。</p>
<p>这种防火墙的不便之处在于每次使用新服务，都必须安装一个相应的代理，由此来操作发起连接。</p>
<p>两大常见形式：</p>
<p>HTTP代理防火墙： 又称作Web代理。根据上面的理解，这种代理防火墙，在内网用户看来是Web服务器，在外部网站看来是Web客户端。同时，这种代理也提供Web缓存功能，顾名思义，就是缓存网页副本，已减少网页延迟，提高用户体验。</p>
<p>SOCKS防火墙：可用于Web之外的服务。例如：第四版为代理传输提供基本支持；第五版增加了强大的认证，UDP传输和IPV6寻址。使用时，应用程序必须先添加SOCKS代理支持功能，同时通过配置应用程序能够获得代理位置及其版本</p>
<hr>
<h2 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h2><p>本质上是一种允许在互联网的<strong>不同地方重复使用相同</strong>的IP地址集的机制</p>
<p>运作原理：当内部系统所有进出的流量均通过一个单独的NAT设备的受，它就将内部的地址空间与全球互联网地址空间分开，这样内部系统就能够使用自己分配的IP地址访问互联网。</p>
<p>然而，我们知道互联网上的用户是没有办法直接访问具有私有地址的主机的。内部系统要正常的连接上网络就必须要让NAT<strong>重写通过路由器的每个数据报包的识别信息</strong>，这很复杂，NAT必须跟踪每个连接的状态，贯穿多个协议层，修改IP地址的同时也要修改传输层的校验码。</p>
<p>讲的具体点就是，它必须重写向某一方向传输的数据包的源IP地址，同样的也要重写向另一个方向传输的数据包的目的IP地址。这样外界看来，这个数据包是来自于具有全局路由IP的NAT路由器，而不是其内部的拥有私有地址的主机。如图所示</p>
<p><img src="https://i.imgur.com/mcIkpKR.jpg" alt=""></p>
<hr>
<h2 id="传统的NAT-基本NAT和NAPT"><a href="#传统的NAT-基本NAT和NAPT" class="headerlink" title="传统的NAT:基本NAT和NAPT"></a>传统的NAT:基本NAT和NAPT</h2><p>基本NAT只执行IP地址的重写，及改内部的私有地址为公共地址。但是它没有办法助于减少IP地址的数量（多少个内部主机希望访问互联网就必须分配多少个公共地址，如果每个主机都访问这样NAT就没有意义了）</p>
<p>NAPT的做法则不同，它使用传输层的标识符，来确定数据包和内部主机的关系。（可以利用相同的公共地址而不同的标识符来区分内部的主机）。内部标识符相同的时候，NAPT也能够重写标识符</p>
<p><img src="https://i.imgur.com/uWeRrQc.jpg" alt=""></p>
<p><strong>注意</strong>这里面有一个问题：如果内部地址所用到的地址刚刚好是自己也想连接的公共地址，那就麻烦了。 所以我们保留了<code>10.0.0.0/8</code>,<code>172.13.0.0/12</code>,以及我们最常见的<code>192.168.0.0/16</code>作为私有地址范围来使用。</p>
<hr>
<p>Yestreday you said tomorrow</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/04/03/防火墙和网络地址转换/" data-id="ck0rl0gxe0026yswis64svtqr" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-ARP地址解析协议" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/29/ARP地址解析协议/">地址解析协议</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/03/29/ARP地址解析协议/" class="article-date"><time datetime="2018-03-29T02:47:47.000Z" itemprop="datePublished">2018-03-29</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>IP协议的设计目标是为了跨越不同类型的物理网络的分组交换提供互操作，这需要网络层软件使用的地址和底层网络硬件使用的地址之间进行转换。</p>
<p>地址解析是发现两个地址之间的映射关系的过程。<strong>地址解析协议ARP</strong>是一个通用的协议，他被设计为支持多种地址之间的映射。ARP提供从网络层地址到相关硬件地址的动态映射。</p>
<hr>
<h2 id="直接交付和ARP"><a href="#直接交付和ARP" class="headerlink" title="直接交付和ARP"></a>直接交付和ARP</h2><p>下面给出IPv4直接交付的基本操作： </p>
<ol>
<li>应用程序使用32位的IPv4地址<code>10.0.0.1</code></li>
<li>应用程序要求TCP协议建立一条到<code>10.0.0.1</code>的连接</li>
<li>通过向<code>10.0.0.1</code>发送一个数据报，TCP尝试向远程主机发送一个连接请求</li>
<li>假设地址该数据报可被直接发送到这个地址，且以太网兼容地址被用于IPv4.</li>
<li>那么，发送的主机就必须将32位的IPv4目的地址转化为48位的以太网地址，这就需要逻辑Internet地址相对应物理硬件地址进行转换，这就是ARP功能。链路层能够将一个消息交付到它连接的所有网路设备，这是ARP运行的一个重要要求</li>
<li>在一个共享的链路层网段，ARP向所有主机发送一个称为ARP请求的以太网帧（链路层广播）。ARP请求包含目的的主机IPv4地址<code>10.0.0.1</code>，并寻找以下答案“如果你将<code>10.0.0.1</code>配置为自己的地址，请向我回应你的MAC地址”</li>
<li>通过ARP，同一广播域中的所有系统都可以接收该请求，如果某系统使用请求中给定的IPv4地址，那么它需要响应一个ARP应答。该应答包含了请求中的IPv4地址和对应的MAC地址。该应答直接发送给请求的发送方。接收ARP请求的主机学习IPv4到MAC地址的映射，并记录在内存中供以后使用</li>
<li>ARP应答被原始请求的发送方接收，现在可以发送引起此次ARP请求/应答的数据报。</li>
<li>发送方可将数据报封装在以太网帧中直接发送到目的主机，应使用由ARP交换学到的以太网作为目的地址。</li>
</ol>
<hr>
<h2 id="ARP缓存"><a href="#ARP缓存" class="headerlink" title="ARP缓存"></a>ARP缓存</h2><p>ARP高效运行的关键是维护每个主机和路由器上的ARP缓存。该缓存使用地址解析为每个接口维护从网络层地址到硬件地址的最新映射。</p>
<h3 id="ARP缓存超时"><a href="#ARP缓存超时" class="headerlink" title="ARP缓存超时"></a>ARP缓存超时</h3><p>超时通常与ARP缓存中的每个条目相关。在大多数实现中，完整条目的超时为20分钟。</p>
<p>软状态是指在超时到达前没有更新而被丢弃的信息。如果网络条件发生改变，软状态有助于启动自动重新配置。</p>
<hr>
<h2 id="免费ARP"><a href="#免费ARP" class="headerlink" title="免费ARP"></a>免费ARP</h2><p>ARP的另一个功能被称为免费ARP，它发生在一台主机发送的ARP请求以寻找自己的地址。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/03/29/ARP地址解析协议/" data-id="ck0rl0gv60004yswis2mgpcsu" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-链路层" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/链路层/">链路层</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/03/28/链路层/" class="article-date"><time datetime="2018-03-28T02:47:47.000Z" itemprop="datePublished">2018-03-28</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>设计链路层的目的是为了IP模板发送和接收IP数据报</p>
<p>大多数链路层技术都有一个相关的协议，描述由网络硬件传输的相应PDU（Protocol Data Unit，协议数据单元） 格式。我们通常称链路层的PDU为<strong>帧</strong></p>
<hr>
<h2 id="以太网和IEEE-802局域网-城域网标准"><a href="#以太网和IEEE-802局域网-城域网标准" class="headerlink" title="以太网和IEEE 802局域网/城域网标准"></a>以太网和IEEE 802局域网/城域网标准</h2><p>以太网这个术语通常指一套标准，由DIX(DEC，Inter公司，Xerox公司)在1980年首次发布。</p>
<p>基本的共享以太网包含一个或多个站（例如工作站，超级计算机），他们被连接到一个共享的电缆上。当介质被确认为空闲状态的时候，链路层的PDU就可以从一个站发送到另一个站。<br><img src="https://i.imgur.com/ShvulDH.jpg" alt=""><br>当因为信号传播延迟造成碰撞时，可被检测到。其导致了发送站等到一个随机事件，然后重新发送数据。这种方法被叫做带冲突检测的载波侦听多路访问（CSMA/CD），但是其更正式的名称是<strong>介质访问控制协议（MAC）</strong></p>
<p>MAC协议有很多类型，有些基于每个站尝试独立使用网络（例如CSMA/CD的基于竞争协议），有些预先安排的协调（例如依据为每个站分配的时段发送）</p>
<p>岁月匆匆，随着以太网的发展，基于竞争的MAC协议已经变得不流行。相反，局域网中每个站之间的线路通常不共享，而是提供了一个专用的星型拓扑结构。这可以通过以太网<strong>交换机</strong>来实现</p>
<p>交换机为以太网中的每个站提供同时发送和接收数据的能力（<strong>全双工以太网</strong>）</p>
<hr>
<h3 id="以太网的帧格式"><a href="#以太网的帧格式" class="headerlink" title="以太网的帧格式"></a>以太网的帧格式</h3><p>（<img src="https://i.imgur.com/rRGpzWJ.jpg" alt=""></p>
<p>以太网帧开始是一个前导字段，接收器电路用它确定一个帧的到达时间。</p>
<p>帧格式包过48位的目的地址（DST）和源地址（SRC）。这些地址又称<strong>MAC地址</strong></p>
<hr>
<h3 id="帧校验序列-循环冗余校验"><a href="#帧校验序列-循环冗余校验" class="headerlink" title="帧校验序列/循环冗余校验"></a>帧校验序列/循环冗余校验</h3><p>循环冗余校验CRC：<br>被检查的消息首先需要追加n位0形成一个扩展消息，然后除以一个约定的n+1位的值，得到一个余数。将该余数的反码（放置在帧校验序列FCS）追加在被检查的消息后面。</p>
<p>在接受到数据后，接受方执行相同的除法计算余数，并判断该值与FCS是否匹配</p>
<hr>
<h3 id="网桥和交换机"><a href="#网桥和交换机" class="headerlink" title="网桥和交换机"></a>网桥和交换机</h3><p>网桥或交换机用于链接多个物理的链路层网络，或成组的站</p>
<p>交换机的本质是高性能的网桥</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.imgur.com/NnvJXvA.jpg" alt=""></h2><h3 id="无线局域网——IEEE-802-11（Wi-Fi）"><a href="#无线局域网——IEEE-802-11（Wi-Fi）" class="headerlink" title="无线局域网——IEEE 802.11（Wi-Fi）"></a>无线局域网——IEEE 802.11（Wi-Fi）</h3><p>无线保真（Wi-Fi）是访问Internet的最流行技术之一</p>
<p>下面了解几个概念 </p>
<ul>
<li>站（STA）  </li>
<li>接入点（AP）  </li>
<li>一个AP和相关的STA被称为一个基本服务集（BSS）  </li>
<li>AP之间通常使用一种有线的分布式服务（DS）连接，形成一个扩展服务集（ESS）即基础设施模式。</li>
</ul>
<h4 id="RTS-CTS和ACK"><a href="#RTS-CTS和ACK" class="headerlink" title="RTS/CTS和ACK"></a>RTS/CTS和ACK</h4><p>802.11网络支持可选的请求发送/明确发送（RTS/CTS），通过放缓传输来进行流量控制：当RST/CTS启用时，一个站在发送数据帧之前，会发送一个RTS帧，当接收方愿意接收额外的流量时，他会响应一个CTS帧。在RTS/CTS交换后，这个站开启一个时间窗口，用于向确认接收的站发送数据帧。</p>
<p>在有限的以太网中，冲突较少意味着正确接收帧的概率较高。在无线网络中更多的因素导致帧交付可能出错，例如信号不够强或受到干扰。为此，802.11采用一种重传/确认（ACK）方法。</p>
<p>确认是对预期在一定时间内接收的一个单播帧或一组帧的响应。在指定时间内没有接收到对应的ACK会导致帧的重传</p>
<hr>
<h2 id="点到点协议"><a href="#点到点协议" class="headerlink" title="点到点协议"></a>点到点协议</h2><p>PPP表示点到点协议，这是一种在串行链路上传输IP数据报的</p>
<p>PPP实际上是一个协议集合，而不是一个单一的协议。它支持建立链接的基本方法，称之为链路控制协议（LCP）以及一系列网络控制协议（NCP）。</p>
<h3 id="链路控制协议"><a href="#链路控制协议" class="headerlink" title="链路控制协议"></a>链路控制协议</h3><p>LCP用于在<strong>点到点链路</strong>上建立和维护底层的双方通讯路径。因此，PPP操作只需关注一条链路的两端。不需要像以太网和WiFi的MAC层协议那样处理共享资源访问的问题</p>
<hr>
<h2 id="MTU和路径MTU"><a href="#MTU和路径MTU" class="headerlink" title="MTU和路径MTU"></a>MTU和路径MTU</h2><p>很多链路层网络中，携带高层协议PDU的帧大小是有限制的，以太网有效载荷的字节数通常被限制为1500，PPP通常采用相同大小以保持与以太网兼容，这种特征被称为<strong>最大传输单元（MTU）</strong></p>
<p>在包含所有链路的整个网络路径上，最小的MTU称为路径MTU。注意，路径通常不对称，路径MTU不需要在两个方向上相同</p>
<hr>
<h2 id="隧道基础"><a href="#隧道基础" class="headerlink" title="隧道基础"></a>隧道基础</h2><p>在某些情况下，两台计算机通过Internet或其他网络建立一条虚拟链路是有用的。虚拟专用网络（VPN）提供这样的服务。实现这类服务的最常用方法称为隧道。</p>
<p>隧道是在高层或同层分组中携带底层数据，其转变了在头部中严格分层的思想，允许形成覆盖网络。</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/03/28/链路层/" data-id="ck0rl0gxa0022yswird9h120w" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  
    <article id="post-Internet地址结构" class="article article-type-post" itemscope itemprop="blogPost">

  <header class="article-header">
    
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/28/Internet地址结构/">Internet 地址结构</a>
    </h1>
  


  </header>

  <div class="article-meta">
    <div class="article-datetime">
  <a href="/2018/03/28/Internet地址结构/" class="article-date"><time datetime="2018-03-28T02:47:47.000Z" itemprop="datePublished">2018-03-28</time></a>
</div>

    
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Study/">Study</a>
  </div>


  </div>
  <div class="article-inner">

    <div class="article-entry" itemprop="articleBody">
      
        <p>连接到Internet的每个设备至少要有一个IP地址。基于TCP/IP协议的专用网络中使用的设备也需要IP地址。</p>
<h2 id="表示IP地址"><a href="#表示IP地址" class="headerlink" title="表示IP地址"></a>表示IP地址</h2><h3 id="IPv4地址："><a href="#IPv4地址：" class="headerlink" title="IPv4地址："></a>IPv4地址：</h3><p>32bit<br>采用点分四组或者<strong>点分十进制</strong>表示。例如165.195.130.105</p>
<h3 id="IPv6地址："><a href="#IPv6地址：" class="headerlink" title="IPv6地址："></a>IPv6地址：</h3><p>128bit<br>采用块或字段的四个十六位进制数表示。例如<code>5f05:2000:80ad:5800:0058:0800:2023:1d71</code></p>
<p>该表示方法有以下共识：  </p>
<ol>
<li>块前导0必须省略，如上面的地址可以写成<code>5f05:2000:80ad:5800:58:800:2023:1d71</code>  </li>
<li>全零的块可以用<code>::</code>省略，但为了避免歧义，仅能使用<strong>一次</strong>且使用在省略块长度最长的地方（当多个省略块长度相同时，省略较高位的块）。例如<code>2001：0：0：0：2：0：0：1</code>可以写成<code>2001::2:0:0:1</code></li>
</ol>
<h2 id="基本的IP地址结构"><a href="#基本的IP地址结构" class="headerlink" title="基本的IP地址结构"></a>基本的IP地址结构</h2><p>IP地址可以根据类型和大小分组，那些用于识别连接Internet或某些专用的内联网的计算机网络接口称为单播地址。此外还有广播、组播和任播地址。但是，IPv6并没有任播地址</p>
<h3 id="分类寻址"><a href="#分类寻址" class="headerlink" title="分类寻址"></a>分类寻址</h3><p>IPv4地址空间最初分成五大类如下图所示<br><img src="https://i.imgur.com/K4PCBOI.jpg" alt=""></p>
<p>A，B，C类用于单播地址，D用于组播而E地址保留。</p>
<p>其地址空间划为如下图所示<br><img src="https://i.imgur.com/nzrUfza.jpg" alt=""></p>
<p>我们很容易可以看出，A，B类的网络号<strong>浪费了太多的主机号</strong>，而C类则不能为很多站点提供足够的主机号。就如同学校中有的教室大，有的教室很小。教务处按上面的方法分配教室的时候，就会出现有的教室只有少部分座位被利用，而有的教室却有很多人没有座位。所以可能有人就建议要建更大的教室，于是就有了IPv6。也有人提出了更加优化的分配方案，这些都是我们之后要谈的。</p>
<h2 id="子网寻址"><a href="#子网寻址" class="headerlink" title="子网寻址"></a>子网寻址</h2><p>子网寻址的想法是，给站点分配A，B，C类的网络号，保留下一些剩余的主机号，让站点自行分配。这种方法使得站点管理员能够在子网数和每个子网预期的主机数中折中，减少了与其他站点的协调。</p>
<p>这就好比学校再不给每个班级分配教室了，而是把这个任务扔给了学院去处理。学院的灵活折中处理稍微的解决下了这个苦恼的问题。</p>
<p>那么什么是子网寻址呢？它是如何工作的呢？<br><img src="https://i.imgur.com/czxmhGd.jpg" alt=""><br>在上图的这个例子中，我们再给定网络号的基础上，选定了8位子网号，剩下的8位为主机号。这样就有256个子网，每个子网可以包含254（256-2，其中子网的第一个和最后一个地址无效）台主机。<strong>注意</strong>：只有划分子网的网络中的主机和路由器知道子网的结构，Internet的其他部分仍将它作为站点相关的地址看待。</p>
<p>那么问题来了，如何知道网络号之后的子码和主机号码是怎么划分的？</p>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码的长度和其IP地址相同。在数值上，子网掩码在对应主机位上均置0，其余位置均置1。于是有<code>255.255.254.0</code>（可以简写成<code>/23</code>）表示前面23位以后才是代表主机号码。</p>
<p>将地址与掩码按位与运算得到路由的地址的网络与子网标识符（前缀）。这样便可以知晓该地址的子网。<br><img src="https://i.imgur.com/rycIxwX.jpg" alt=""></p>
<p>在对同一站点的不同部分，将不同长度的子网掩码应用于相同的网络号，就形成了<strong>可变长度子网掩码（VLSM）</strong>。</p>
<h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><p>广播地址是该IP地址与掩码取反进行或运算的结果。</p>
<p>当目的地址为某广播地址，如上图的<code>128.32.1.255</code>时，数据报将发送给目标站点的所有主机</p>
<h2 id="CIDR和聚合"><a href="#CIDR和聚合" class="headerlink" title="CIDR和聚合"></a>CIDR和聚合</h2><p>无类别域间路由（CIDR）和聚合为解决下列原因而出现  </p>
<ol>
<li>B类地址耗尽  </li>
<li>路由表的条目数增加  </li>
</ol>
<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>使用CIDR，未经过预定义的任何地址范围都可以作为一个类的一部分，但是需要一个类似子网掩码的掩码，称之为CIDR掩码。<strong>CIDR掩码不再局限于一个站点，而对全球性路由系统都是可见的</strong></p>
<p>除了网络号之外，核心Internet路由器必须能解释和处理掩码，这样的数字组合称为<strong>网络前缀</strong></p>
<p>消除IP地址中网络和主机号的预定义分隔，将使更细粒度的IP地址分配范围成为可能。</p>
<p>例如<code>192.125.3.0</code> 写成前缀形式：<code>192.125.3.0/24</code>。A 类和 B 类网络号用前缀 <code>/8</code> 和 <code>/16</code> 表示</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>减少路由表的条目数也很重要，就好比你在十字路口碰到了无数多的道路指向牌，你也会蒙蔽的。所以人们就想出了一些方法。</p>
<p>我们想到，路由表的条目数利用网络拓扑排列成一棵树，如果这棵树的上一层能够和目的IP地址的较高位吻合，接下的每一层依次匹配下来，就可以节省大量的时间。</p>
<p>做到这样的树，就要通过<strong>路由聚合</strong>这个过程来实现，即：</p>
<p>将相邻的多个IP前缀合并成一个短前缀，这样就可以覆盖更多的地址空间。而合并的方法便是进行按位与运算。</p>
<p><img src="https://i.imgur.com/f1SD5hD.png" alt=""></p>
<h2 id="特殊用途地址"><a href="#特殊用途地址" class="headerlink" title="特殊用途地址"></a>特殊用途地址</h2><hr>
<p>这里暂时不举例</p>
<p>###组播地址</p>
<p>一个IP组播地址标识一组主机接口，而不是单个接口。</p>
<p>站点管理员可将路由器配置为管理范围边界，这意味着相关组的组播流量不会被路由器转发</p>

      
    </div>

    
      

    

    <footer class="article-footer">
      <a data-url="https://pandaeathzr.github.io/2018/03/28/Internet地址结构/" data-id="ck0rl0gvf0009yswi9cuzkkv4" class="article-share-link">
        <i class="fa fa-share"></i> Share
      </a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TCP-IP/">TCP/IP</a></li></ul>


    </footer>
  </div>
  
</article>



  


  <div id="page-nav">
    <nav><ul class="pagination"><li><a class="page-prev" rel="prev" href="/page/2/"><i class="fa fa-chevron-left"></i> Prev</a></li><li><a class="page-number" href="/">1</a></li><li><a class="page-number" href="/page/2/">2</a></li><li class="active"><span class="page-number">3</span></li><li class="disabled"><span class="page-next">Next <i class="fa fa-chevron-right"></i></a></li></ul></nav>
  </div>



        </div>
        <div class="col-sm-3 col-sm-offset-1 blog-sidebar">
          
  <div class="sidebar-module sidebar-module-inset">
  <h4>About</h4>
  <p><b>New Life!</b></p>

</div>


  
  <div class="sidebar-module">
    <h4>Tags</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/JaveScript/">JaveScript</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/Linux/">Linux</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/MySQL/">MySQL</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/RYU/">RYU</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/SDN/">SDN</a><span class="sidebar-module-list-count">4</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/TCP-IP/">TCP/IP</a><span class="sidebar-module-list-count">10</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/numpy/">numpy</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/tags/python/">python</a><span class="sidebar-module-list-count">7</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Archives</h4>
    <ul class="sidebar-module-list"><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/10/">October 2019</a><span class="sidebar-module-list-count">2</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2019/09/">September 2019</a><span class="sidebar-module-list-count">3</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/07/">July 2018</a><span class="sidebar-module-list-count">5</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/06/">June 2018</a><span class="sidebar-module-list-count">1</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/05/">May 2018</a><span class="sidebar-module-list-count">6</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/04/">April 2018</a><span class="sidebar-module-list-count">10</span></li><li class="sidebar-module-list-item"><a class="sidebar-module-list-link" href="/archives/2018/03/">March 2018</a><span class="sidebar-module-list-count">3</span></li></ul>
  </div>



  
  <div class="sidebar-module">
    <h4>Recents</h4>
    <ul class="sidebar-module-list">
      
        <li>
          <a href="/2019/10/08/掘金_水波图实现原理/">掘金学习_水波图实现原理</a>
        </li>
      
        <li>
          <a href="/2019/10/07/掘金_前端程序员必须掌握之三角函数在前端动画中的应用/">掘金学习_前端程序员必须掌握之三角函数在前端动画中的应用</a>
        </li>
      
        <li>
          <a href="/2019/09/20/一题_JS_2/">一题_JS_2</a>
        </li>
      
        <li>
          <a href="/2019/09/20/我不知道的深浅拷贝/">我不知道的深浅拷贝</a>
        </li>
      
        <li>
          <a href="/2019/09/13/新起点/">新的起点</a>
        </li>
      
    </ul>
  </div>



        </div>
    </div>
  </div>
  <footer class="blog-footer">
  <div class="container">
    <div id="footer-info" class="inner">
      &copy; 2019 Huzr<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

  

<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js" integrity="sha384-8gBf6Y4YYq7Jx97PIqmTwLPin4hxIzQw5aDmUg/DDhul9fFpbbLcLh3nTIIDJKhx" crossorigin="anonymous"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</body>
</html>
